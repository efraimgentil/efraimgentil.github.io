

Java memory management

Java Heap Space

Is used by jave runtime to allocate memory to Objects and JRE classes. Whenener we create any object, it's always created in the Heap space.
the Stack memory only contains the reference for the object, Objects stored in the heap are globally accessible whereas stack memory can't be accessed by other threads

When Heap memory is full Java runtime throws java.lang.OutOfMemoryError: Java Heap Space error.

Stack Memory

Is used for execution of a thread. They contain method specifc values that are short-lived and references to other objects in the heap that are getting referred from the method. Stack memory is always referenced in LIFO (Last in First Out) order. Whenever a method is invoked, a new vlock is created in the stack memory for the method to hold local primitive values and reference to opther objects in the method, Stack memory size is very less compared to Heap memory 

Stack memory only contains local primitive variables and reference variables to objects in heap space

When stack memory is full, java runtime throws java.lang.StackOverFlowError







#######


Young generation, when the young generation is filled the garbage colletion is perfomed, this collection is called Minor GC. the Young generation is divided into three parts - Eden Memory and Two Suvivor Memory spaces.

Important points about the Young Generation Spaces

- Most of the newly created objects are located in the Eden memory space
- When Eden space is filled with objects, Minor GC is performed and all the survivor objets are moved to one of the suvivor spaces
- Minor GC also checks the suvivor objects and move then to the other survivor space. So at a time one of the survivor space is always empty
- Object that survived after many cycles of GC, are moved to the Old generation memory space.
Usually it`s done by setting a threshold for the age of the younh generation objects before they become eligible to promote to Old generation



Old Generation

Old Generation memory contains the objects that are long lived and survived after many rounds of Minor GC. Usually garbage collection is performed in Old Generation memory when it`s full. Old Generation Garbage COllection is called Major GC, it usually takes longer time.

Permanent Generation

Perm Gen contains the application metadata required by the JVM to describe the classes and methods used in teh application. Note that perm Gen is not part of Java Heap Memory. Perm Gem is populated by JVm at runtime based on the classes used by the application. PermGen also contains Java SE library classes and methods. Perm Gen objects are garbage collected in a full garbage collection

Method Area

Part of space in the Perm Gen and used to store class structure ( runtime constats and static variables) and code for methods and constructors 


Memory Pool

Is created by JVM memory managers to create a pool of immutable objects, if implementation supports it. String Pool is a good example of this kind of memory pool. Memory Pool can belong to Heap or Perm Gen, depending on the JVM memory manager implementation.


Runtime Constant Pool

Is per-class runtime representation of constant pool in a class. it contains class runtime constants and static methods. Runtime constant pool is the part of method area.

Stack Memory

Is used for execution of a thread. They contains method specific values that are shortlived and references to ohter objects in the head that are getting referred from the method.


################################3


# Garbage Collector is the program running in the background that looks into all the objects in the memory and find out the objects that are not referenced by any part of the program. All these unreferenced objects are deleted and space is reclaimed for allocation to other objects.

One of the basic way of garbage collection involves three steps:
 1. Marking: This is the first step where garbage collector identifies which objects are in use and which ones are not in use
 2. Normal Deletion: Garbage COllector removes the unused objects and reclaim the free space to be allocated to other objects.
 3. Dellection with Compacting: For better performance, after deleting unused objects, all the survived objects can be moved to be together. This will increase the performance of allocation of memory to newer objects.


#####

Stop the World Event

All the garbage collections are "Stop the World" because all application threads are stopped until the operation complets
Since Young generation keeps short-lived objects, Minor GC is very fast and the application doesn`t get affected by this.

Major GC takes logner time because it checks all the live objects. Major GC should be minimized because it will make your application unresponsive for the garbage collection fduration. So if you have a responsive application and there are a lot of major garbage collection happening, you will notice timeout errors.

The duration taken by garbage collection depends on the strategy used for garbage collection. That`s why it`s necessary to monitor and tune the garbage collector to avoid timeouts in the highly responsive applications.



######

#What is write once, run anywhere?

Java code is compiled down into a intermidiary lenguage called byte code. The JVM is responsible for executing this byte code. This is unlike lenguages such as C++ which are compiled directly to native code for specific platform.

# What is JIT (Just in Time)? 

The JVM executes bytecode, however, if it determines a section of code is being run frequently it can optionally compile a section down to native code to increase the speed of execution. The smallest block that can be JIT compiled is a method. By default, a piece of code needs to be executed 1500 times for it to be JIT compiled. This leads to the concept of warming up the JVM . The downside JIT compilation is not free, it takes time and resource when it occurs.

# What do we mean when we say memory is managed in Java? What is the garbage collector

In lenguages like C the developer has direct access to memory. The code literally references memory space addresses. This can be difficult and dangerous, and can reasult in damaging memory leaks. In Java all memory is managed, we deal exclusively in objects and primitives and we have no concept of what is happening underneath with regards to memory and pointers, and java has the concept of garbage collector, when objects are no longer needed the JVM will automatically identify and clear the memory space for us.

# What are the benefits and negatives of Garbage Collector? 

 The developers can worry much less about memory management and concentrate on actual problem solviing

 The GC has a lot of smart algorithms for memory management  which work automatically in the background

 the negative side: 

  When the GC occurs it has effect on the application performance, notably slowing it down or stopping it(so called Stop the World). This can be unacceptable depending on the application requirements, although GC tunning can minimise or even remove the impact.

  Although it possible to do a lot of tuning with the garbage collector, you cannot specify when or how the application performs GC.


# What is Stop the World

 Is when the GC happens and is necessary to completely pause the threads in an application whilst collection occurs 

# how does Generational GC works?

The Java Heap is divided into generations, New Generation that is short lived objects, those objects are quickly collected, all new objects are placed into the new generation. Heap is splited into

New Generation (is splited up further)
  - Eden Space: All new objects are placed in here. When it becomes full a minor GC occurs, all objects that are still referenced are then promoted to a suvivor space.
  - Suvivor Space: The implementation of whis space varies based on the JVM, but the premise is the same. On each collection in the New Generation increments the age of the objects in the suvivor space, when it suvives enought number of GC( default vary but normaly is 15) it will be promoted to the Old Generation
  ### GC in the new generation is known as 'minor GC'

Old Generation

   Any object that suvive from suvivor spaces in the new generation are promoted to the old generation, Old  Generation is much larger than the New Generation. When GC occurs in the Old Generation it is known as Full GC(also known Stop the World) and tend to take longer. There is a number of algorithms available for GC:

    - Serial GC: For computers that have only one CPU, and stops the entire application to run the GC. it uses mark-sweep-compact, it goes through all the objects and marks which objects are elected for GC before clearing them out.
    - Parallel GC: Similar to Serial, except that it uses multiple threads to perform the GC so it should be faster.
    - Concurrent Mark Sweep (CMS): Minimises pauses by doing most of the GC work concurrently with the processing of the application. This minimises the amount of time when the application has to completely pause and so lends itself much better to application which are sensitive to this.
     - Garbage First Garbage Collector (G1GC): Similar to CMS, but does not suffer from fragmentation problems

PermGen

	Is where the JVM stores the metadata about classes. It no longer exists in Java 8 having been replaced with metaspace. Generally the PermGen doesn't require any tunning above ensuring it has enough space, it can lead to lekas if classes are not being unloaded properly.

# Which is better? Serial , Parallel or CMS

 	It depends on the application, serial is better if you're on a single CPU, or in a scenario where there are more VMs running on the machine than CPUs. Parallel is good if you have a lot of work to do but are ok with pauses. CMS is the best of the three if you need consistent responsiveness with minimal pauses.

# You can tell the system to perform a GC ? 

 You can suggest the JVM to perform the GC ussing the System.gc(), however there is no guarantee this will do anything, this can also depend of the JVM your code is running at. There is also a flag to disable it from doing anything -XX:+DisableExplicitGC

 # What does finalize() do? 

  Is a default method in the Object class, and exist for all objects, the default implementation does nothing. It is called by the GC when it determines there are no more references to the object, but there is no guarantees the code will ever be executed and should not be used to execute actual functionality, it will never be called more than once on an object (by the JVM) 

  







